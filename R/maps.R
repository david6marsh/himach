# maps
#
# Functions for plotting nice maps of routes


# return polygon square based on sf bbox
bbox_to_poly <- function(b, crs){
  st_sfc(st_polygon(list(matrix(c(b$xmin,b$ymin,
                                  b$xmax,b$ymin,
                                  b$xmax,b$ymax,
                                  b$xmin,b$ymax,
                                  b$xmin,b$ymin),
                                ncol=2, byrow=TRUE))),
         crs=crs)
}


#wrapper around ggplot/geom_sf for quick map
plot_map <- function(msf,
                     c_land = "green1",
                     c_border = "grey70",
                     w_border = 0.1){
  ggplot2::ggplot(msf) +
    ggplot2::geom_sf(size = w_border, colour = c_border, fill = c_land) +
    # coord_sf() + #not needed for already-projected feature sets
    ggplot2::theme_minimal()
}


# achievable range from a point
# not used for route finding
rangeEnvelope <- function(ac, route_grid, ap2, fat_map,
                          envelope_points=70){
  #range envelope shows how far from an airport you can go  with a given range
  #it takes the first airport of the given airport pair
  #create no-wind range ellipse
  #transform the origin
  projC <- st_transform(st_sfc(st_point(
    c(ap2$from_long, ap2$from_lat)),
    crs=4326),crs=st_crs(fat_map))

  r <- ac$range_km * 1000

  theta <- seq(0, 2* pi, length.out = envelope_points)
  circle <- matrix(c(r*cos(theta), r*sin(theta)), ncol=2)

  ellipse <- t(circle) +
    as.vector(st_coordinates(projC))

  st_convex_hull(st_sfc(st_multipoint(t(ellipse)),crs=st_crs(fat_map)))
}


#' Map a set of routes
#'
#' \code{map_routes} plots routes, with many options
#'
#' This function plots the routes, with options for additional layers. Multiple
#' routes are expected, and they can be coloured by time advantage, by speed
#' along each segment, or by aircraft type.
#'
#' The option \code{show_route} "time" requires 'advantage_h' to have been added to
#' the routes set, from the route summary. If it hasn't then this is done in a local
#' version, then discarded. Running \code{summarise_routes} to do this requires an
#' airport dataset; if \code{is.na(ap_loc)} then this is not available, so a default set
#' is used. You can turn on \code{warn} to see if this is happening, but by default it
#' is silent.
#'
#' @param \code{thin_map} The minimum is a \code{MULTIPOLYGON} map, 'thin' in
#'   that it is without buffer, so a normal coastline map.
#' @param \code{routes} as generated by \code{\link{findRoute}}
#' @param \code{crs} Coordinate reference system, default \code{crs_Atlantic}.
#' @param \code{show_route}  one of "speed", "aircraft", "time" to indicate what
#'   goes in the legend.
#' @param \code{fat_map} optional coast + buffer map, default NA.
#' @param \code{avoid_map} optional map of no-fly zones, default NA.
#' @param \code{ap_loc} Show used origin and destination airports if this
#'   is a set of airports from \code{\link{make_airports}}, or not if NA
#'   (default). This dataset can be all airports, and is filtered to those used
#'   by \code{routes}.
#' @param \code{ap_col,ap_size} Colour and size of used airport markers (dark
#'   blue, 0.4)
#' @param \code{refuel_airports} Show these airports (usually the refuel ones)
#'   or nothing if NA (default).
#' @param \code{rap_col,rap_size} Colour and size of refuel airport markers
#'   (red, 0.4)
#' @param \code{crow,crow_col,crow_size} If TRUE, show the 'crow-flies' direct
#'   great circle, in colour \code{crow_col} and thickness \code{crow_size}.
#'   Default FALSE, "grey70", 0.2
#' @param \code{range_envelope} show the route envelope (default FALSE).
#' @param \code{e_col,e_alpha,e_size} colour, alpha and width for the range
#'    envelope. Default "grey70", 0.4, 0.6
#' @param \code{bound,bound_margin_km} If bound=TRUE (default) crop to bounding
#'   box of the \code{routes}, with additional \code{bound_margin_km} in km
#'   (default 200)
#' @param \code{land_f,buffer_f,avoid_f} fill colours for thin, fat and no-fly
#'   maps, default grey 90, 70 and 80, respectively
#' @param \code{l_alpha,l_size} line (route) settings for alpha (transparency)
#'   and width, defaults 0.6 and 0.4.
#' @param \code{warn} if TRUE show some warnings (when defaults loaded) (default FALSE)
#'
#' @return Dataframe with details of the leg
#'
#' @import sf
#' @import dplyr
#' @import tidyr
#' @import ggplot2
#'
#' @examples
#' #see introductory vignette
#'
#' @export
map_routes <- function(
  thin_map, routes=NA, crs=crs_Atlantic, show_route="time",
  fat_map=NA, avoid_map=NA,
  ap_loc=NA, ap_col="darkblue", ap_size=0.4,
  crow=FALSE, crow_col="grey70", crow_size=0.2,
  range_envelope=FALSE,
  bound=TRUE, bound_margin_km=200,
  land_f="grey90", buffer_f="grey60", avoid_f="grey80",
  l_alpha=0.8, l_size=0.5,
  e_alpha=0.4, e_size=0.6, e_col="grey70",
  refuel_airports=NA, rap_col="red", rap_size=0.4,
  warn = FALSE
){
  (stopifnot(is.na(show_route) || show_route %in% c("speed","aircraft","time")))

  #thin map is the one without buffer
  thin_map <- prj(thin_map, crs=crs) #force to CRS used for this map

  #layer 1 (one or two base maps)
  if (is.na(fat_map)) {
    m <- plot_map(thin_map, c_border=NA, c_land=land_f)
  } else {
    m <- plot_map(prj(fat_map, crs=crs), c_border=NA, c_land=buffer_f) +
      geom_sf(data=thin_map, fill=land_f, colour=NA)
  }

  #layer 2 (no fly-zone)
  if (!is.na(avoid_map)){
    m <- m +
      geom_sf(data = prj(avoid_map, crs=crs), colour=avoid_f, fill=avoid_f)
  }

  #layer 3 (main lines)
  if (show_route=="time"){
    # check if 'advantage_h' has been calculated
    if ( !("advantage_h" %in% names(routes)) ) {
      if (warn) message("Adding advantage_h temporarily to the routes set.")
      airports <- ap_loc
      if (!is.data.frame(airports)){
        airports <- make_airports(warn = FALSE)
        if (warn) message("Using default airport set for temporary route summary.")
      }
      rtes <- summarise_routes(routes, airports)
      routes <- routes %>%
        left_join(rtes %>% select(fullRouteID, advantage_h),
                  by = "fullRouteID") %>%
        arrange(advantage_h)
    }
    m <- m +  labs(colour="Time Advantage") +
      geom_sf(data = routes,
              aes(geometry=st_wrap(prj(gc, crs=crs)), colour=advantage_h), fill="white",
              size=l_size, lineend="round", alpha=l_alpha) +
      scale_colour_viridis_c()
  }
  if (show_route=="speed"){
    m <- m +  labs(colour="Average speed on segment (kph)") +
      geom_sf(data = routes,
              aes(geometry=st_wrap(prj(gc, crs=crs)), colour=speed_kph),
              size=l_size, lineend="round", alpha=l_alpha) +
      scale_colour_viridis_c()
  }

  #layer 4: crow-flies
  if (crow){
    m <- m +
      geom_sf(data = st_wrap(prj(routes$crow, crs=crs)), colour=crow_col, size = crow_size)
  }

  #layer 5: range envelope
  if (range_envelope){
    m <- m +
      geom_sf(data = st_wrap(st_cast(prj(routes$envelope, crs=crs), 'MULTILINESTRING')),
              fill = NA,
              colour = e_col, alpha = e_alpha, size = e_size)
  }

  #layer 6: airports
  if (is.data.frame(ap_loc)){
    used_APs <- sort(unique(unlist(lapply(unique(routes$routeID),
                                     function(x)strsplit(x, "<>")))))
    APs <- ap_loc %>% filter(APICAO %in% used_APs)
    m <- m +
      geom_sf(data = APs,
              aes(geometry=prj(ap_locs, crs=crs)), colour=ap_col, size=ap_size)
  }

  #layer 7: refuel airports
  if (is.data.frame(refuel_airports)){
    used_refuel_APs <- sort(unique(routes$refuel_ap))
    rAPs <- refuel_airports %>% filter(APICAO %in% used_refuel_APs)
    m <- m +
      geom_sf(data = rAPs,
              aes(geometry=prj(ap_locs, crs=crs)),
              colour=rap_col, size=rap_size)
  }

  #apply bounds?
  if (!is.na(routes) && bound){
    #crop based on the bounding box of all of the routes
    bbox <- st_bbox(prj(routes$gc, crs=crs)) +
      # c(-1,-1,1,1)*10 #zoomed box + 10deg
      c(-bound_margin_km,-bound_margin_km,bound_margin_km,bound_margin_km)*10^3 #zoomed box + 1000km - Robinson or orig
    m <- m +
      xlim(bbox$xmin, bbox$xmax) + ylim(bbox$ymin, bbox$ymax)
  }

  m <- m +
    theme(legend.position = "bottom")

  return(m)
}



#wrapper for st_wrap_dateline, because it needs lat-longs
st_wrap <- function(m){
  #this can be used wihtin a geom_sf plot statement
  st_transform(st_wrap_dateline(st_transform(m, crs=twospeed:::crs_latlong)),
               crs=st_crs(m))
}
