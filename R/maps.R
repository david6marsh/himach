# maps
#
# Functions for plotting nice maps of routes


# return polygon square based on sf bbox
bbox_to_poly <- function(b, crs){
  st_sfc(st_polygon(list(matrix(c(b$xmin,b$ymin,
                                  b$xmax,b$ymin,
                                  b$xmax,b$ymax,
                                  b$xmin,b$ymax,
                                  b$xmin,b$ymin),
                                ncol=2, byrow=TRUE))),
         crs=crs)
}

# return a polygon from c(xmin, xmax, ymin, ymax)
# b is in crs, default to lat long
edges_to_poly <- function(b, in_crs = crs_latlong, to_crs = in_crs){
  st_transform(st_sfc(st_polygon(list(matrix(c(b[1],b[3],
                                               b[2],b[3],
                                               b[2],b[4],
                                               b[1],b[4],
                                               b[1],b[3]),
                                             ncol=2, byrow=TRUE))),
                      crs=in_crs), crs = to_crs)
}

#wrapper around ggplot/geom_sf for quick map
plot_map <- function(msf,
                     c_land = "green1",
                     c_border = "grey70",
                     w_border = 0.1){
  ggplot2::ggplot(msf) +
    ggplot2::geom_sf(size = w_border, colour = c_border, fill = c_land) +
    # coord_sf() + #not needed for already-projected feature sets
    ggplot2::theme_minimal()
}


# achievable range from a point
# not used for route finding
rangeEnvelope <- function(ac, route_grid, ap2, fat_map,
                          envelope_points=70){
  #range envelope shows how far from an airport you can go  with a given range
  #it takes the first airport of the given airport pair
  #create no-wind range ellipse
  #transform the origin
  projC <- st_transform(st_sfc(st_point(
    c(ap2$from_long, ap2$from_lat)),
    crs=4326),crs=st_crs(fat_map))

  r <- ac$range_km * 1000

  theta <- seq(0, 2* pi, length.out = envelope_points)
  circle <- matrix(c(r*cos(theta), r*sin(theta)), ncol=2)

  ellipse <- t(circle) +
    as.vector(st_coordinates(projC))

  st_convex_hull(st_sfc(st_multipoint(t(ellipse)),crs=st_crs(fat_map)))
}


#' Map a set of routes
#'
#' \code{map_routes} plots routes, with many options
#'
#' This function plots the routes, with options for additional layers. Multiple
#' routes are expected, and they can be coloured by time advantage, by speed
#' along each segment, or by aircraft type.
#'
#' The option \code{show_route} "time" requires 'advantage_h' to have been added to
#' the routes set, from the route summary. If it hasn't then this is done in a local
#' version, then discarded. Running \code{summarise_routes} to do this requires an
#' airport dataset; if \code{is.na(ap_loc)} then this is not available, so a default set
#' is used. You can turn on \code{warn} to see if this is happening, but by default it
#' is silent.
#'
#' @param thin_map The minimum is a \code{MULTIPOLYGON} map, 'thin' in
#'   that it is without buffer, so a normal coastline map.
#' @param routes as generated by \code{\link{find_route}}
#' @param crs Coordinate reference system, default \code{crs_Atlantic}.
#' @param show_route  one of "speed", "aircraft", "time", "circuity" to
#'   indicate what goes in the legend.
#' @param fat_map optional coast + buffer map, default NA.
#' @param avoid_map optional map of no-fly zones, default NA.
#' @param ap_loc Show used origin and destination airports if this
#'   is a set of airports from \code{\link{make_airports}}, or not if NA
#'   (default). This dataset can be all airports, and is filtered to those used
#'   by \code{routes}.
#' @param ap_col,ap_size Colour and size of used airport markers (dark
#'   blue, 0.4)
#' @param refuel_airports Show the used refuel airports using these
#'   locations, or nothing if NA. (Defaults to same as \code{ap_loc}.)
#' @param rap_col,rap_size Colour and size of refuel airport markers
#'   (red, 0.4)
#' @param crow,crow_col,crow_size If TRUE, show the 'crow-flies' direct
#'   great circle, in colour \code{crow_col} and thickness \code{crow_size}.
#'   Default FALSE, "grey70", 0.2
#' @param route_envelope show the route envelope (default FALSE).
#' @param e_col,e_alpha,e_size colour, alpha and width for the range
#'    envelope. Default "grey70", 0.4, 0.6
#' @param bound,bound_margin_km If bound=TRUE (default) crop to bounding
#'   box of the \code{routes}, with additional \code{bound_margin_km} in km
#'   (default 200)
#' @param land_f,buffer_f,avoid_f fill colours for thin, fat and no-fly
#'   maps, default grey 90, 70 and 80, respectively
#' @param l_alpha,l_size line (route) settings for alpha (transparency)
#'   and width, defaults 0.6 and 0.4.
#' @param scale_direction Passed to scale_colour_viridis, either -1 (default) or
#'   or 1.
#' @param title,subtitle Passed to ggplot.
#' @param warn if TRUE show some warnings (when defaults loaded) (default FALSE)
#'
#' @return Dataframe with details of the leg
#'
#' @import sf
#' @import dplyr
#' @import tidyr
#' @import ggplot2
#'
#' @examples
#' #see introductory vignette
#'
#' @export
map_routes <- function(
  thin_map, routes=NA, crs=Mach2::crs_Atlantic, show_route="time",
  fat_map=NA, avoid_map=NA,
  ap_loc=NA, ap_col="darkblue", ap_size=0.4,
  crow=FALSE, crow_col="grey70", crow_size=0.2,
  route_envelope=FALSE,
  bound=TRUE, bound_margin_km=200,
  land_f="grey90", buffer_f="grey60", avoid_f="grey80",
  l_alpha=0.8, l_size=0.5,
  e_alpha=0.4, e_size=0.6, e_col="grey70",
  refuel_airports=ap_loc, rap_col="red", rap_size=0.4,
  scale_direction = -1,
  title = "", subtitle = "",
  warn = FALSE
){
  (stopifnot(is.na(show_route) || show_route %in% c("speed","aircraft","time", "circuity")))

  # remove the non-routes (have time = NA)
  # these are where refuelling was needed
  if (is.data.frame(routes)) routes <- routes %>% filter(!is.na(time_h))

  #thin map is the one without buffer
  thin_map <- st_wrap_transform(thin_map, crs=crs) #force to CRS used for this map

  #layer 1 (one or two base maps)
  if (is.na(fat_map)) {
    m <- plot_map(thin_map, c_border=NA, c_land=land_f)
  } else {
    m <- plot_map(prj(fat_map, crs=crs), c_border=NA, c_land=buffer_f) +
      geom_sf(data=thin_map, fill=land_f, colour=NA)
  }

  #layer 2 (no fly-zone)
  if (!is.na(avoid_map)){
    m <- m +
      geom_sf(data = prj(avoid_map, crs=crs), colour=avoid_f, fill=avoid_f)
  }

  # 3: prelim: check if summarise_routes has been run
  # by seeing if 'advantage_h' has been calculated
  if (is.data.frame(routes)) {
    if ( !("advantage_h" %in% names(routes))) {
      if (warn) message("Adding advantage_h temporarily to the routes set.")
      airports <- ap_loc
      if (!is.data.frame(airports)){
        airports <- make_airports(warn = FALSE)
        if (warn) message("Using default airport set for temporary route summary.")
      }
      rtes <- summarise_routes(routes, airports)
      routes <- routes %>%
        left_join(rtes %>% select(.data$fullRouteID, .data$advantage_h, .data$circuity),
                  by = "fullRouteID") %>%
        arrange(.data$advantage_h)
    }

    #layer 3 (main lines)
    if (show_route=="time"){

      m <- m +  labs(colour = "Time Advantage") +
        geom_sf(data = routes,
                aes(geometry=st_wrap(prj(.data$gc, crs=crs)), colour=.data$advantage_h), fill="white",
                size=l_size, lineend="round", alpha=l_alpha) +
        scale_colour_viridis_c(direction = scale_direction)
    }
    if (show_route=="circuity"){
      m <- m +  labs(colour = "Circuity\n(best=0)") +
        geom_sf(data = routes,
                aes(geometry=st_wrap(prj(.data$gc, crs=crs)), colour=.data$circuity), fill="white",
                size=l_size, lineend="round", alpha=l_alpha) +
        scale_colour_viridis_c(direction = scale_direction,
                               labels = scales::percent)
    }
    if (show_route == "speed"){
      m <- m +  labs(colour = "Average speed on segment (kph)") +
        geom_sf(data = routes,
                aes(geometry=st_wrap(prj(.data$gc, crs=crs)), colour=.data$speed_kph),
                size=l_size, lineend="round", alpha=l_alpha) +
        scale_colour_viridis_c(direction = scale_direction)
    }
    if (show_route == "aircraft"){
      m <- m +  labs(colour = "Aircraft") +
        geom_sf(data = routes,
                aes(geometry = st_wrap(prj(.data$gc, crs=crs)),
                    colour = .data$acID),
                size=l_size, lineend="round", alpha=l_alpha,
                show.legend = "line")+
        scale_colour_viridis_d(direction = scale_direction)
    }
  }

  #layer 4: crow-flies
  if (crow){
    m <- m +
      geom_sf(data = st_wrap(prj(routes$crow, crs=crs)), colour=crow_col, size = crow_size)
  }

  #layer 5: range envelope
  if (route_envelope){
    m <- m +
      geom_sf(data = st_wrap(st_cast(prj(routes$envelope, crs=crs), 'MULTILINESTRING')),
              fill = NA,
              colour = e_col, alpha = e_alpha, size = e_size)
  }

  #layer 6: airports
  if (is.data.frame(ap_loc)){
    used_APs <- sort(unique(unlist(lapply(unique(routes$routeID),
                                     function(x)strsplit(x, "<>")))))
    APs <- ap_loc %>% filter(.data$APICAO %in% used_APs)
    m <- m +
      geom_sf(data = APs,
              aes(geometry=prj(.data$ap_locs, crs=crs)), colour=ap_col, size=ap_size)
  }

  #layer 7: refuel airports
  if (is.data.frame(refuel_airports)){
    used_refuel_APs <- sort(unique(routes$refuel_ap))
    rAPs <- refuel_airports %>% filter(.data$APICAO %in% used_refuel_APs)
    m <- m +
      geom_sf(data = rAPs,
              aes(geometry=prj(.data$ap_locs, crs=crs)),
              colour=rap_col, size=rap_size)
  }

  #apply bounds?
  if (!is.na(routes) && bound){
    #crop based on the bounding box of all of the routes
    bbox <- st_bbox(prj(routes$gc, crs=crs)) +
      # c(-1,-1,1,1)*10 #zoomed box + 10deg
      c(-1,-1,1,1) * bound_margin_km * 10^3 #zoomed box + 1000km
    m <- m +
      xlim(bbox$xmin, bbox$xmax) + ylim(bbox$ymin, bbox$ymax)
  }

  m <- m +
    labs(title = title, subtitle = subtitle) +
    theme(legend.position = "bottom")

  return(m)
}



# wrapper for st_wrap_dateline, because it needs lat-longs
# works for multilines without GDAL problems
st_wrap <- function(m){
  #this can be used wihtin a geom_sf plot statement
  st_transform(st_wrap_dateline(st_transform(m, crs = crs_latlong),
                                options = c("WRAPDATELINE=YES")),
               crs=st_crs(m))
}

# wrap a single SF object
# geom, with bb (in long-lat)
wrap_ <- function(geom, break_long, marg){
  # if (st_is(geom, "POLYGON")){
  #     (st_is(geom, "MULTIPOLYGON") && length(geom[[1]]) == 1)) {
  # if (TRUE) {
    bb <- st_bbox_longlat(geom)
    long_prob <- ( break_long > bb$xmin & break_long < bb$xmax )
    if (!st_is_empty(geom) && long_prob) {
      # in case bounding box is very small
      marg <- min(marg, (bb$xmax - bb$xmin)/20)
      # get West and East parts
      # in the _current_ crs of geom
      box_W <- edges_to_poly(c(bb$xmin, break_long - marg, bb$ymin, bb$ymax))
      geom_W <- st_intersection(st_transform(box_W, st_crs(geom)), geom)
      box_E <- edges_to_poly(c(break_long + marg, bb$xmax,  bb$ymin, bb$ymax))
      geom_E <- st_intersection(st_transform(box_E, st_crs(geom)), geom)
      geom <- st_union(geom_W, geom_E)
    }
    return(geom)
  # }
}

#wrapper for st_bbox that always returns lat-longs
st_bbox_longlat <- function(m){
  bb <- st_bbox(m)
  if (!st_is_longlat(bb)) {
    bb <- st_bbox(st_transform(m,
                       crs = crs_latlong))
  }
  return(bb)
}

# handle wrapping of objects around the 'dateline' or opposite end of the map
# expect m to be a map data frame, with geometry
# splits prior to an st_transform
# marg is a small amount in degrees trimmed off the side

#' Wrap the 'dateline' before \code{st_transform}
#'
#' \code{st_wrap_transform} handles the 'far side' break first, then
#' \code{st_tranform}
#'
#' \code{\link[sf:st_transform]{st_wrap_dateline}} should handle the break in a
#' map projection but uses `GDAL` for this. Given persistent issues in
#' installing  GDAL, \code{st_wrap_transform} achieves the same, at least for
#' simple map projections, without needing GDAL. This is only needed for
#' polygons, otherwise \code{\link[sf:st_transform]{st_wrap_dateline}} works
#' without the GDAL issues.
#'
#' Here 'simple' means, with a dateline that is a single line of longitude: ie
#' the proj4string contains either "longitude_of_center", so the dateline is
#' that +180; or not, in which case it assumes the "longitude_of_center" is 0.
#'
#'
#' @param m A map dataframe, ie of class \code{sf} and \code{data.frame}
#' @param crs Destination coordinate reference system, as in \code{st_tranform}
#' @param marg Any polygons that cross the dateline lose a small margin, for
#'   safety
#'
#' @return \code{sf} dataframe, same as the parameter \code{m}
#'
#' @import sf
#' @import dplyr
#' @import tidyr
#'
#' @examples
#' world <- sf::st_as_sf(rnaturalearthdata::coastline110)
#' w_pacific <- st_wrap_transform(world, crs_Pacific)
#' ggplot2::ggplot(w_pacific) + ggplot2::geom_sf()
#'
#' # bad - not run - dateline problem example
#' # ggplot2::ggplot(st_transform(world, crs_Pacific)) +
#' #   ggplot2::geom_sf()
#'
#' @export
st_wrap_transform <- function(m, crs, marg = 0.05){
  # get 'dateline' of original map proj in longitude
  # where the break in the map will be after a transformation
  # to get the crs as a string, transform a small box...

  # nothing to do if already there
  if (st_crs(m) == st_crs(crs)) return(m)

  small_box <- edges_to_poly(c(1,2,1,2), to_crs = crs)
  break_long <- mod_long(long_cent(small_box) + 180)

  if ("sf" %in% class(m) && "data.frame" %in% class(m) &&
      all(st_is(m, c("POLYGON", "MULTIPOLYGON")))) {
    # loop over dataframe rows
    len <- nrow(m)
    new_geo <-  m %>%
      st_geometry() %>%
      split(1:len)  %>%
      purrr::modify( wrap_,
                     break_long = break_long, marg = marg) %>%
      unsplit(1:len)
    st_geometry(m) <- new_geo
  } else if (all(st_is(m, c("POLYGON", "MULTIPOLYGON")))) {
    # simpler case
    m <- wrap_(m, break_long = break_long, marg = marg)
  } else {
    warning("only handles single (multi)polygons or sf of polygons")
  }

  st_transform(m, crs)
}

#find the longitude of centre
long_cent <- function(m){
  #full text version of crs
  tx <- st_as_text(st_crs(m))
  tx <- stringr::str_remove_all(tx, "\"") #get rid of these
  if (!stringr::str_detect(tx, "longitude_of_center")){
    # if not mentioned, default to 0
    c_long <- 0
  } else {
    c_long <- as.numeric(gsub(".*longitude_of_center,(.+?)].*",
                              "\\1",
                              tx))
  }
  c_long
}
