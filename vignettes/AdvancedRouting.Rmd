---
title: "Advanced Supersonic Routing"
author: "David Marsh"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette  
vignette: >
  %\VignetteIndexEntry{Advanced Supersonic Routing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Introduction

[Supersonic Routing](SupersonicRouting.html) provides a quick end-to-end introduction to using the `Mach2` package and is the place to start. This vignette provides advice on more advanced use, explaining details that the introduction skates over.

Much of this vignette is optional or for occasional use, but the advice on saving and reading the caches is likely to be _essential_ for a speedy workflow. 


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
#the libraries needed for the vignette are
library(Mach2)
library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(ggplot2)
library(sp)
library(sf)

```


## Caches {#caches}

`Mach2` uses caching to speed things up. Legs are cached in `route_cache` and arrival-departure links to airports are cached in `star_cache` (STAR is short for standard arrival route, its counterpart being SID the standard instrument departure). These sit in the `.m2_cache` namespace, so you use `$`, eg `.m2_cache$route_cache`, to refer to them.

Normally the caches just do the job. But you will want to save and load them as part of your standard workflow. Quite where you save them is up to you, but a set of routes is sensitive to (a) the route grid on which it is calculated (b) the list of aircraft used, and their performance. 

So it is recommended to include the `name` of the grid, and the `aircraftSet` attribute of your aircraft set in the file name. Everything else is up to you.

If you change either of these, then you can use `m2_clean_cache()` to empty the caches. You will also note that if you run `find_routes` and the map has changed, or `findToCToD` and the map or aircraft have changed, then the caches will be cleared automatically.

We don't execute this code chunk here, since the files aren't available.

```{r cache saving, eval=FALSE} 
# at the beginning of the session
# some data loading including
# load a GridLat: p_grid_a
# load an aircraft set: ac
# and then...

#not run
m2_load_caches(paste("data/route_start_cache_", p_grid_a@name, 
                           attr(ac,"aircraftSet"), " 2050v3.RDS"))

# then calculate however many new routes

#not run
#Save the cache ----
# see example in next chunk


```
  
Usually, the caches just work invisibly in the background - you will notice they speed up finding of routes no end. They also help with refuelling, because the `route_cache` quickly remembers the routes from major hub airports to the main refuelling points, so they don't need to be calculated again.

Incidentally, if you add a new refuelling point, then the caches remain _valid_ because only **legs are cached, not routes**. With a new refuelling point, `find_route` will check both old legs and new, cached or not, before selecting the best combination of legs to make the route.

Here we illustrate a few use cases for more general management of the cache. First, the code chunk takes a little time to generate a few routes, and hence the two caches. The use cases are:

1. How big is my cache? How many legs or arrival/departure links does it contain?
2. Remove a single item. If you think the input data were wrong, for example. Two steps, list the possible candidates using a search string, then copy paste the name of the one you want (usually obvious based on aircraft and airport-pair) into the code for deletion.
3. Remove all legs for a single airport, for example if the location turned out to be wrong. Then update the lat-long and re-run. This pattern is easily adapted to airport pairs (all different aircraft), or all for a given aircraft.
4. If you think you have merged caches from 2 different versions of `Mach2` in which the contents of a route dataframe have changed, then this is for you. Of course that never happens.


```{r inspecting the cache}
#first create a cache ----
# need to load some of the built-in data
m2_clean_cache() # for this example, start with empty caches
aircraft <- make_aircraft()
airports <- make_airports(crs = crs_Pacific) 
refuel_ap <- airports %>%
  filter(APICAO=="NZWN")
NZ_buffer_Pac <- sf::st_transform(NZ_buffer30, crs=crs_Pacific)

ap2 <- matrix(c("NZAA","NZCH","NZAA","NZDN","NZGS","NZCH"), 
              ncol = 2, byrow = TRUE)
ac <- aircraft[c(1,4), ]$id

options("quiet" = 0) # just the progress bar
NZ_routes <- find_routes(ac, ap2, aircraft, airports,
                      fat_map = NZ_buffer_Pac, 
                     route_grid = NZ_grid,
                     refuel = refuel_ap,
                     temp_cache_path = NA)

# now have the 2 caches ----
# for the vignette we put in a temp directory, you don't want to do this
m2_save_caches("v0", NZ_grid, aircraft, tempdir()) 

# 
# # Use case 1: How big is my cache? 
# length(.m2_cache$route_cache) # this is number of legs, not routes
# length(.m2_cache$star_cache)
# # quiz: why are they not the same length?
# 
# # Use case 2: find and remove a single leg
# # find matching elements in the rte cache - here for NZAA
# ls(.m2_cache$route_cache, pattern = "NZAA")
# # copy paste from the results into here to remove a single item
# rm("M22_test-NZAA-NZCH--TRUE-TRUE-NA-TRUE-100-12", envir = .m2_cache$route_cache)
# 
# # Use case 3: remove all legs for a given airport
# length(.m2_cache$route_cache)
# rm(list=ls(.m2_cache$route_cache, pattern="NZDN"), envir = .m2_cache$route_cache)
# length(.m2_cache$route_cache)
# 
# # Use case 4: check for out-of-date elements in the cache
# # in this case check if consistent with 'new' version where there are 24 variables
# # get number of variables in each element in rte cache
# route_cols <- lapply(1:length(.m2_cache$route_cache), 
#                      function(x) length(get(ls(.m2_cache$route_cache)[1],
#                                             .m2_cache$route_cache)))
# wrong <- which(route_cols != 24)

```


# No-fly zones

It is not unusual for parts of the airspace to be closed, or be considered unsafe for flying. `Mach2` allows regions to be marked as 'avoid'. They will not feature in the grid, so routes will avoid them, with one exception: an arrival or departure airport can be inside a no-fly zone, as long as the connection point to the grid is outside. So they might more precisely be called 'no-overfly' zones.

A no-fly zone is prepared in the same way as a map of land. If specific countries are to be avoided, this is where having a country name in the geographic data comes in handy.

One essential item is the `avoid` attribute of the no-fly zone. This is used to distinguish sets of legs with different, or no, no-fly zone.

In this example, no offence is intended to the citizens of Buller District of New Zealand; it is a convenient example for showing how routes are forced to change when airspace is unavailable.

```{r createBuffer}
# using your own shp file 
# NZ_Buller <- sf::read_sf("...../territorial-authority-2020-clipped-generalised.shp") %>% 
#     filter(TA2020_V_1 == "Buller District")
# NZ_Buller_u <- sf::st_union(sf::st_simplify(NZ_Buller, dTolerance = 1000))
# NZ_Buller_buffer50 <- sf::st_union(sf::st_buffer(NZ_Buller_u, 50 * 1000))
# attr(NZ_Buller_buffer50, "avoid") <- "Buller+50km"
# the quicker version, using a built-in no fly zone
Buller_nofly <- sf::st_transform(NZ_Buller_buffer40, crs=crs_Pacific)
attr(Buller_nofly, "avoid") <- "Buller+40km" #required for correct caching

# run the same routes, but with the avoid region
options("quiet"= 0) #just the progress bar
ac <- aircraft[c(4), ]$id
routes <- find_routes(ac, ap2, aircraft, airports,
                      fat_map = NZ_buffer_Pac, 
                      route_grid = NZ_grid,
                      refuel = refuel_ap,
                      cf_subsonic = aircraft[3,],
                      avoid = Buller_nofly)

#this shows versions of the legs with and without no-fly
# ls(route_cache, pattern = "NZCH", envir = .m2_cache)

# create route summary
rtes <- summarise_routes(routes, airports)

# draw a basic map
NZ_coast_Pac <- sf::st_transform(NZ_coast, crs=crs_Pacific)
map_routes(NZ_coast_Pac, routes, crs = crs_Pacific, fat_map = NZ_buffer_Pac,
          avoid_map = Buller_nofly)

map_routes(NZ_coast_Pac, routes, show_route = "aircraft",
           crs = crs_Pacific, fat_map = NZ_buffer_Pac,
          avoid_map = Buller_nofly)

```


# Too many ocean routes: Buffer widths and projections {#bufferaccuracy}

Above 60 or 70 (North or South), the approximations used by the `st_buffer` function begin to show signs of exceeding their limits. In particular, if you're adding a 50km coastal buffer, for example, there are separations between Canadian islands which are just under 100km. Borden and Ellef Ringnes are examples. A buffer generated by `st_buffer` shows the strait between them as open water, where it should be closed. 

This can lead to over-optimistic routings: supersonic where they should not be. 

The solution is to use the links from `sf` to the `s2` package which come in more recent versions of the `sf` package. This does require you to use quite a high value for the `max_cells` parameter of `s2::s2_buffer_cells`.

```{r buffers in s2, fig.width=7, eval = FALSE}
gr <- s2::s2_data_countries(c("Greenland", "Canada", "Iceland"))
gr_buffer_s2 <- s2::s2_buffer_cells(gr, distance = 50000, max_cells = 20000) %>%
   st_as_sfc()
m_s2 <- ggplot(st_transform(gr_buffer_s2, crs_Atlantic)) + geom_sf(fill = "grey40") +
   geom_sf(data = st_transform(st_as_sfc(gr), crs_Atlantic))

sf_use_s2(FALSE) # to be sure
gr_transf <- gr %>%
   st_as_sfc() %>%
   st_transform(crs_Atlantic)
gr_t_buffer <- gr_transf %>%
   st_buffer(dist = 50000)
m_old <- ggplot(gr_t_buffer) + geom_sf(fill = "grey40") + geom_sf(data = gr_transf)

cowplot::plot_grid(m_old, m_s2, labels = c("bad", "good"),
                   ncol = 1)

```

![Incorrect and Correct Buffer](buffer_example.pdf) 

In fact, the problem of finding too many apparently over-ocean routes is broader than this. The other main contributor to this is missing islands from the map. See the comments [in the first vignette](SupersonicRouting.html#maps).

An example of this is in the same place. Some maps omit small islands (well, larger ones like Killniq down to tiny ones like Goodwin Island) at the mouth of the Hudson Strait. This affects the apparent width of the opening. Given the islands, and a 50km buffer, the Strait is _not_ open as the next example shows.

(This uses a non-CRAN, but public package of hi-resolution maps. If you don't want to load it, just note the results in the figure.)

```{r Island Example, fig.width=7, eval = FALSE}
sf::sf_use_s2(TRUE)
hires <- sf::st_as_sf(rnaturalearthhires::countries10) %>% 
  filter(NAME %in% c("Greenland", "Canada", "Iceland"))
hires_buffer_s2 <- s2::s2_buffer_cells(hires, distance = 50000, max_cells = 20000) %>%
   st_as_sfc()
m_hires <- ggplot(st_transform(hires_buffer_s2, crs_Atlantic)) + 
  geom_sf(fill = "grey40") +
   geom_sf(data = st_transform(hires, crs_Atlantic))

cowplot::plot_grid(m_s2, m_hires, labels = c("good", "better"),
                   ncol = 1)

```

![Correct Buffer and with Better with More Islands](buffer_island_example.pdf)
