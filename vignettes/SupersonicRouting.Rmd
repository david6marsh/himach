---
title: "Introduction to Supersonic Routing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Supersonic Routing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Introduction

This vignette provides an end-to-end example of using the `twospeed` package to find the quickest route for a supersonic aircraft that is allowed to fly supersonic over sea, but only subsonic over land.


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(twospeed)
library(dplyr)
library(ggplot2)

```


## Aircraft

You need a dataframe that defines one or more aircraft. This needs, at minimum, to have the following fields:

* `id` and `type`: a very short, and longer text identifier for this aircraft
* `over_sea_M` and `over_land_M`: the eponymous two speeds, given as a Mach number
* `accel_Mpm`: acceleration in Mach per minute between these two
* `arrdep_kph`: the speed on arrival and departure from aircraft, given in km per hour
* `range_km`: range in km

Other fields are optional, but it is recommended to include `notes` to give more information. 

Run this minimum dataset through `expand_aircraft` to get the additional fields that are needed. Alternatively, if you run `expand_aircraft` with no parameters, it creates a set of test aircraft. 

`expand_aircraft` also adds some additional fields, converting Mach to kph, and calculating the time to transition between the two speeds. This 'transition penalty' `trans_h` in hours, is used in the routing search as a time penalty whenever a transition from subsonic to supersonic (or vice versa) is needed; typically this is when switching from flying over land to flying over sea (or vice versa).


```{r define aircraft} 

# example for your own data
# aircraft <- read.csv("data/aircraft.csv", stringAsFactors = FALSE)
# aircraft <- expand_aircraft(aircraft)
# strongly recommended to record the file name for later reference
# attr(aircraft, "aircraftSet") <- "aircraft.csv"

# example if you have no data of your own
aircraft <- expand_aircraft()

```

## Airports

Similarly, we need a dataset describing airports. This needs, at minimum, to have the following fields:

* `APICAO`: the 4-character ICAO code for the airport
* `long` and `lat`: the longitude and latitude, in decimal degrees (E and N being positive)

Other fields are optional, but you might find it useful to include `ap_name` to give more information, as well as other fields containing geographical details, such as country. 

As with the airports, you can load your own data set and then run it through `expand_airports` to add a geo-coded field to it. If you don't have a list, then `expand_airports` will use the dataset from `airportr` package.

For this vignette, we use a very restricted set: just New Zealand.

```{r define airports}

# example for your own data
# airports <- read.csv("data/airports.csv", stringAsFactors = FALSE)
# airports <- expand_airports(airports)

# example if you have no data of your own
airports <- expand_airports() %>% 
  filter(substr(APICAO,1,1)=="N") #just New Zealand

```

In fact you need two airport sets, because you need to say where flights can stop to refuel. If an aircraft cannot make a journey in a single leg, due to lack of range, `twospeed` automatically searches for the best refuelling option. This can easily multiply the number of searches by 5 or 10, so choose a limited number of likely 'good' options: islands, coastal points, or on narrow segments of land where the aircraft would have to slow down anyway. In our case, we have a test aircraft with an artifically reduced range, and we make just one refuel point available: coastal and central at the same time, Wellington.

```{r define refuel points}

refuel_ap <- airports %>% 
  filter(APICAO=="NZWN")

```

## Maps

Next you need a set of shapefiles covering your area of interest (usually worldwide). These need only to distinguish land and sea, but starting off at country level can be useful, for example to filter out the Antarctic, which is not likely to see traffic. Fine resolution is better, because small islands can become larger obstacles: after a no-fly coastal buffer, typically around 30km wide, is applied, even a 1km wide island is an obstacle 61km wide. 

Licensing and your intended use may influence which maps are available to you. We have used data from Eurostat in the past (at 1:1M scale) [Eurostat country shape files](https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units/countries). 

For the purpose of testing and this vignette, we use a map which is provided by [Stats NZ](https://www.stats.govt.nz/information-releases/geographic-boundary-data-annual-release-as-at-1-january-2020) and licensed by Stats NZ for re-use under the Creative Commons Attribution 4.0 International licence. 

In fact, we need two files: one is the basic outline of the land, largely used for visualisation; the second is derived from this, and adds a 30km buffer around the coastline to indicate the area where supersonic flight is not allowed. A different buffer is possible, though 30km is about right for the expected width of the footprint of the supersonic boom.

Since the shape file is large, we provide a simplified outline `NZ_u` and also the buffer `NZ_b`. These are in the original projection used by Stats NZ `sf::st_crs(NZ_u)`. It's strongly recommended to use one of the following:

* Robinson 54030, a mid 20C classic view, with Atlantic centre
* A Pacific-centred variant on this with `crs=CRS("+proj=robin +lon_0=150 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")`.

We leave this tranformation step in the process to emphasise the need to think about which projection to use.

```{r load maps}

# if you are using your own shp file 
# NZ_shp <- sf::read_sf("...../territorial-authority-2020-clipped-generalised.shp")
# NZ_u <- sf::st_union(sf::st_simplify(NZ_shp, dTolerance = 1000))
# NZ_b <- sf::st_union(sf::st_buffer(NZ_u, 30 * 1000))

crs_Pacific <- sp::CRS("+proj=robin +lon_0=150 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")

# We project the in-built test maps
NZ_coast <- sf::st_transform(twospeed::NZ_u, crs=crs_Pacific)
NZ_buffer <- sf::st_transform(twospeed::NZ_b, crs=crs_Pacific)

# All that remains is to illustrate the land and buffer
ggplot(NZ_buffer) +
    geom_sf(colour = NA, fill = "grey75")  +
      geom_sf(data = NZ_coast, fill = "grey90", colour = NA)+
    theme_minimal()

```

## Create a grid

The route is constructed on a grid that covers the entire map. You could think of this as being at some high, cruise flight level, though `twospeed` doesn't assign a flight level to it. The links in this grid have nominal length: 30-40km appears sufficient, though we will use a coarser grid for this test. In fact the grid is constructed along lines of latitude, so the links vary in length.

To this are added connections to airports. These connections have a nominal length, say 150km, to represent the distance covered when accelerating to cruise speed, or decelerating back when landing. In practice, the length varies, because it depends on the distance from airport to grid.

It can take a very long time to construct a grid. For our much-reduced example the time might be a second or two.

```{r construct grid}

target_km=100
system.time(
p_grid <- newLatLongGrid(NZ_buffer,"NZ lat-long at 100km",
                             target_km = target_km, classify = TRUE,
                         lat_min = -49, lat_max = -32, 
                         long_min = 160, long_max = 180)
)

ggplot(NZ_buffer) +
    geom_sf(colour = NA, fill = "grey75")  +
      geom_sf(data = NZ_coast, fill = "grey90", colour = NA) +
  geom_sf(data = p_grid@lattice,
          aes(geometry=geometry), colour="lightblue", size = 0.2) +

    theme_minimal()

```

